---
title: 正则表达式入门笔记
date: 2018-12-24 16:08:05
tags: JS
---

**正则一直是我弱项，闲着没事写笔记学习吧~**

#### RegExp 对象

js 的内置对象 RegExp 支持正则表达式
有两种方法实例化 RegExp 对象

- 字面量 var reg = /a/
- 构造函数 var reg = new RegExp('/a/')

#### 元字符

正则表达式由两种基本字符类型组成

- 原义文本字符，也就是我想搜索 a 那就/a/
- 元字符，在正则表达式中有特殊含义的非字母字符比如\b 边界，以及 \* + ? ^ () {} []

| 字符 |        含义         |
| ---- | :-----------------: |
| \t   |     水平制表符      |
| \v   |     垂直制表符      |
| \n   |       换行符        |
| \r   |       回车符        |
| \o   |       空字符        |
| \f   |       换页符        |
| \cX  | 与 X 对应的控制字符 |

#### 字符类

有时候我们不想特指某个字符，想匹配某个范围内

- 我们可以用元字符 [] 来构建一个简单的类
- 所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符
- 表达式[abc]就把字符 a,b,c 归为一类，表达式可以匹配这类的字符

字符类取反

- 使用元字符^创建反向类/负向类
- 反向类的意思是不属于某类的内容
- 表达式[^abc]标识不是字符 a,b,c 的内容

#### 范围类

我们想匹配所有数字，或者所有字母的时候，正则提供了范围类

- [a-z]就表示从 a 到 z 的任意字符
- 这是个闭区间，也包含 a 和 z 本身
- 也可以连着写[a-zA-Z0-9],如果想匹配-这个字符就在匹配的后面加上-例如[a-z-]

#### 预定义类+边界

| 预定义类+边界 |               含义               |
| ------------- | :------------------------------: |
| .             | 除了换行符和回车符以外的所有字符 |
| \d            |         数字字符([0-9])          |
| \D            |        非数字字符([^0-9])        |
| \s            |              空白符              |
| \S            |             非空白符             |
| \w            |      单词字符([a-zA-Z_0-9])      |
| \W            |            非单词字符            |
| ^             |           以 xxxx 开始           |
| \$            |           以 xxxx 结束           |
| \b            |             单词边界             |
| \B            |            非单词边界            |

#### 量词

当你希望匹配一个数字出现 20 次的时候，你可以这样写/\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d/......这样写是极其不友好，谁写是傻子

| 字符  |               含义               |
| ----- | :------------------------------: |
| ?     | 出现 0 次或者 1 次(最多出现一次) |
| +     |   出现一次或多次(最少出现一次)   |
| \*    |     出现 0 次或多次(任意次)      |
| {n}   |            出现 n 次             |
| {n,m} |          出现 n 到 m 次          |
| {n,}  |          至少出现 n 次           |

#### 贪婪模式和非贪婪模式

比如表达式\d{3,6}，可以匹配到三个数字，也可以是四个五个六个......来看例子

```
'12345678'.replace(/\d{3,6}/g,'A')
'A78'
```

从这可以看出正则表达式默认的是尽可能多的匹配，而不是只匹配到第三个就结束了，这就是贪婪模式

**非贪婪模式**

让正则表达式尽可能少的匹配，也就是说一旦成功匹配不再继续尝试，就是非贪婪模式
做法很简单，在量词后加上?即可

```
'12345678'.replace(/\d{3,6}?/,'X')
"X45678"
```

#### 分组

比如我们想匹配 abc 3 次的时候我们可以这样写
`abc{3}`
但是这样写就会匹配 c 的 3 次，而不是整个字母 abc 的 3 次，要想作用于整个字母就要使用()来分组
`(abc){3}`

**或**
js 里边是 || 而正则是使用 | 可以达到或的效果
`a|c`

**反向引用**
2015-15-25 => 25/15/2015
`'2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/,'$3/$2/$1')`
如果你不希望捕获分组可以在()内加上?:
`(?:\d{2})`

#### 前瞻和后瞻

| 名称     |     正则      |
| -------- | :-----------: |
| 正向前瞻 | exp(?=assert) |
| 负向前瞻 | exp(?!assert) |

exp(?=assert) 的意思就是比如你要匹配 a 但是 a 后边必须要跟上数字 就是这样写/\w(?=\d)/，上代码看下和平常的区别

```
'a2b2'.replace(/\w\d/,'A')
"Ab2"
'a2b2'.replace(/\w(?=\d)/,'A')
"A2b2"
```

#### 对象属性

### 修饰符

- g:global 全局搜索，不添加，搜索到第一个停止
- i:ignore case 忽略大小写，默认大小写敏感
- m:multiple lines 多行搜索
- lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置,该属性只有设置标志 g 才能使用。
- source 正则表达式的文本字符串

### test

用于测试字符串参数中是否存在匹配正则表达式模式的字符串

```
/\d/g.test('0')
true
```

但是你多执行几次就会出现...

```
var reg = /\d/g
reg1.test(0)
true
reg1.test(0)
false
reg1.test(0)
true
reg1.test(0)
false
```

这是为撒呢？因为 test 是以 lastIndex 属性所指的位置作为下次检索的起始点，所以你就可以遍历一个字符串的所有文本,等它再也找不到可以匹配的文本时，它会自动把 lastIndex 属性重置为 0，所以返回了 false

```
var reg = /\w/g

while(reg.test('ab')){
  console.log(reg.lastIndex)
}

1
2
```

### exec

使用正则表达式对字符串进行搜索，如果没有匹配返回 null，匹配到返回结果数组,数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是正则中分组中表达式相匹配的值，一次类推，看实例

```
var reg = /\d(\w)\d/
var ret = reg.exec('$5a51s28e6')
console.log(ret.index,reg.lastIndex,ret.toString(),ret.input)

1
0
"5a5,a"
"$5a51s28e6"
```

从实例中可以看出 exec()方法还返回两个属性，index 属性声明的是匹配文本的第一个字符的位置，input 属性则存放的是被检索的字符串 string。
其中 5a5 是检索到的字符串，而 a 是分组(\w)检索出来的属性，再换个写法试试

```
var reg = /\d(\w)(\w)\d/
var ret = reg.exec('$5aw51s28e6')
console.log(ret.toString())

"5aw5,a,w"
```

a 和 w 都是分组中两个属性

#### 字符串的对象方法

_search_

search()方法用于检索字符串中指定的子字符串，或检索与正则表达式想匹配的子字符串，方法返回第一个匹配结果 index，查找不到返回-1，search 方法不支持全局匹配，忽略标志 g，并且从字符串的开始进行检索

```
'1w5w2w'.search('1')
0
'1w5w2w'.search('10')
-1
```

_match_

match()方法将检索字符串，找到一个或多个与正则匹配的文本，是否标志 g 对结果影响很大
