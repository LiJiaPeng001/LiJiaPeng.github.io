<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试题收集]]></title>
    <url>%2F2019%2F02%2F20%2FInterview%2F</url>
    <content type="text"><![CDATA[想必大家很厌烦笔试，因为脑海中都是一些分散的知识点，无法关联成网，一直处于时曾相识的状态。不知道多少人和我一样，至今每次写阻止冒泡都需要百度一番如何拼写。 CSS1.盒模型页面渲染时，dom元素所采用的布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为： content-box (W3C 标准盒模型,在宽度和高度之外绘制元素的内边距和边框) border-box (为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制) inherit (从父元素继承 box-sizing 属性的值) 2.层叠上下文 z-index属性值并不是在任何元素上都有效果。它仅在定位元素（定义了position属性，且属性值为非static值的元素）上有效果 判断元素在Z轴上的堆叠顺序，不仅仅是直接比较两个元素的z-index值的大小，这个堆叠顺序实际由元素的层叠上下文、层叠等级共同决定。层叠上下文通俗的讲就是，两个父元素各自有一个子元素，子元素全部设置有position和z-index，那么这时候因为父元素没有设置z-index，所以没有产生上下文，此时z-index谁大谁就在上面,如果两个父元素同时设置了z-index,就算你其中子元素的z-index设置了99999也没用，因为你的父元素所产生的层叠上下文比别人的小，也就是z-index。 3.居中布局水平居中 行内元素: text-align:center 块级元素: margin:0 auto absolute+transform（position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);） flex+justify-content:center 垂直居中 line-height:height absolute+transform flex+align-items:center display: table-cell 水平垂直居中 absolute+transform flex+justify-content+align-items 4.选择器优先级 !important &gt; 行内样式 &gt; #id &gt; .class &gt; tag &gt; * &gt; 继承 &gt; 默认 选择器从右往左解析 5.去除浮动影响，防止父级高度塌陷 通过增加尾元素清除浮动(::after{content:’’;clear:both;display:block;}) 父级设置高度 父元素设置overflow:hidden; javascript1.原型 / 构造函数 / 实例12345678原型(prototype):一个简单的对象，用于实现对象的属性继承。可以简单的理解成对象的爹。在Firefox和Chrome中，每个JavaScript对象中都包含一个 __proto__(非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。构造函数:可以通过new来新建一个对象的函数。实例: 通过构造函数和new创建出来的对象，便是实例,实例通过 __proto__指向原型，通过constructor指向构造函数。实例.__proto__ === 原型原型.constructor === 构造函数构造函数.prototype === 原型原型.constructorr === 构造函数 2.原型链123原型链是由原型对象组成，每个对象都有__proto__属性，指向了创建该对象的构造函数的原型，__proto__将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。具体还是去这个网站吧https://www.jianshu.com/p/dee9f8b14771 3.作用域作用域其实可理解为该上下文中声明的变量和声明的作用范围。可分为块级作用域和函数作用域 声明提前: 一个声明在函数体内都是可见的, 函数优先于变量 非匿名自执行函数，函数变量为只读状态，无法修改123456const foo = 1(function foo() &#123; foo = 10 // 由于foo在函数中只为可读，因此赋值无效 console.log(foo)&#125;())// 结果打印： ƒ foo() &#123; foo = 10 ; console.log(foo) &#125; 4.作用域链我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。 5.闭包闭包属于一种特殊的作用域，称为静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。闭包也会产生一个问题： 多个子函数都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。解决方法： 变量可以通过函数参数的形式传入 使用块级作用域，让变量成为自己上下文的属性，避免共享 6.对象的拷贝浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign …扩展运算符深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响 当值为函数或 undefined时，无法拷贝 JSON.parse(JSON.stringify(obj)): 性能最快 递归进行逐一赋值 7.new运算符的执行过程 新生成一个对象 链接到原型prototype 绑定this 返回新对象 8.代码的复用 函数封装 继承 混入 mixin模式（感觉和继承差不多鸭） 借用 apply/call 9.继承在JS中，继承通常指的便是原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。 使用 ES6 的语法糖 class/extends 10.类型转换在JS中在使用运算符号或者对比符时，会自带隐式转换，规则如下: -、*、/、% ：一律转换成数值后计算 [1].toString()===’1’ {}.toString()===’[object object]’+： 数字 + 字符串 = 字符串， 运算顺序是从左到右 数字 + 对象， 优先调用对象的 valueOf -&gt; toString 数字 + boolean/null = 数字 数字 + undefined == NaN 11.类型判断判断类型，单单用 typeof 并无法完全满足，这其实并不是bug，本质原因是JS的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待 基本类型(null): 使用 String(null) 基本类型(string/number/boolean/undefined) + function: 直接使用 typeof即可 其余引用类型(Array/Date/RegExpError): 调用 toString后根据 [objectXXX]进行判断 12.模块化 es6: import/exports commonjs: require/module.exports/exports require与 import的区别 require支持动态导入， import不支持，正在提案 (babel下可支持) require是同步导入， import属于异步导入 require是值拷贝，导出值变化不会影响导入值； import指向内存地址，导入值会随导出值而变化 13.防抖与节流具体看前几篇的博客 14.this指向要明白this指向，其实就是要搞清楚函数的运行环境，说人话就是，谁调用了函数。例如: obj.fn()，便是 obj 调用了函数，既函数中的 this===obj fn()，这里可以看成 window.fn()，因此 this===window 但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向: call:fn.call(target,1,2) apply:fn.apply(target,[1,2]) bind:fn.bind(target)(1,2) 这三种方式在前几篇博客有详情 15.ES6/ES7 声明:let/const: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明,const: 声明常量，无法修改 解构赋值 class/extend: 类声明与继承 Set/Map: 新的数据结构 Promise的使用与实现,await/async 具体参考阮一峰的es6入门：http://es6.ruanyifeng.com/#README 16.数组 map: 遍历数组，返回回调返回值组成的新数组 forEach: 无法 break，可以用 try/catch中 thrownewError来停止 filter: 过滤 sort(fn)/reverse: 排序与反转，改变原数组 concat: 连接数组，不影响原数组， 浅拷贝……. 浏览器常见状态码 1xx: 接受，继续处理 200: 成功，并返回数据 201: 已创建 202: 已接受 203: 成为，但未授权 204: 成功，无内容 205: 成功，重置内容 206: 成功，部分内容 301: 永久移动，重定向 302: 临时移动，可使用原有URI 304: 资源未修改，可使用缓存 305: 需代理访问 400: 请求语法错误 401: 要求身份认证 403: 拒绝请求 404: 资源不存在 500: 服务器错误 get / postget: 缓存、请求长度受限、会被历史保存记录post: 安全、大数据、更多编码类型 框架：Vue1.nextTick在下次 dom更新循环结束之后执行延迟回调，可用于获取更新后的 dom状态 2. 生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed]]></content>
      <tags>
        <tag>jacascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年我绝对不会再买的东西]]></title>
    <url>%2F2019%2F01%2F20%2Fshop%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我的工资都浪费在哪些地方？top1 鞋子据统计今年我总共买了四双鞋子，总共花费约800元左右，无法想象，记得以前我买了两双特步换着穿两三年才有闲钱换了新的，现在真有点膨胀，这四双鞋中，买完就后悔的有两双，首先是阿迪的这双不懂为什么阿迪的41号跟别家的41号不同，我穿着有一点显大而且很容易拖鞋垫，就是你大街上走着走着鞋垫就从后脚跟拖出来了…反正我现在穿它基本就不垫鞋垫了，透气性很适合春夏秋穿至于弹性还行吧跟想象的不一样，接下来是特步家的,这双鞋弹性一般透气可以质量差评，刚穿了一个月撑起鞋舌的那个穿孔就掉了- -…剩下两个还是特步家的，一个运动鞋一个老爹鞋，目前没有任何问题，穿着舒适 top2 烤箱和面包机也不是不能不买，而是买了之后感觉有点用处但是有点鸡肋，18年刚工作的时候想给家里添件电器，家里其他也不缺而我当时被烘焙洗脑了就花了几百块买了个烤箱给我妈，买烤箱的目的就只有一个做面包！但由于技术实在太菜每次都做成馒头硬的不像话，不过实话实说烤箱的质量很不错，但但是！我妈不会烘焙我也是屁股塞黄豆一窍不通，所以主要的功能就是我回家后做鸡胸肉了其余时间都在闲置着，过了一段时间不甘心的我在年中的时候买了一台面包机，这下好了傻瓜式操作，面粉和水的比例说明书都有，总算是满足了我做面包的念想,做了几次后就乏味了，成本太高味道不理想也弃了偶尔健身拿来做早餐吃也是美滋滋 top3 质量差的生活用品没什么好解释的贪便宜买的价格看起来还行，其实我是蹭了商家的活动，买一赠一，收到衣服后会返回支付款的一半，这些衣服买来之后或多或少都会出现些问题，起毛了等等等等，相比起我在优衣库买的衣服简直就是个屁 top4 伪文艺小清新生活用品记得在淘宝上第一眼看见就喜欢的不得了，买来之后也装了几天衣服后来因为被褥枕头太多就当成集装箱用了…..还有一些瓶子笔盒什么的我都不知道自己当时脑子怎么想的，我还在屋子里用塑料杯种了一些草…. top5 健身之类的..觉得好酷炫就买了，结果还不如我原先是用过的杯子… top6 电锅从此我知道了宁愿买电磁炉加铁锅也不能买电锅，再买吃一吨屎！ top7 住宿以后再租房的话不会再租这么贵了，一年光房租花了我1W7.8]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js防抖和节流]]></title>
    <url>%2F2018%2F12%2F28%2Fjs%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[JS防抖&emsp;&emsp;最近在做公司商城项目时候，有个需求就是购物车里边，数量input框需要根据你当前输入的值，每次输入都要发送更新请求，然后后端进行计算，前端重新渲染页面，那么问题来，我每次输入一个数字都会发送一个请求到后端，这样就非常的浪费资源，页面加载也会变慢，于是我查看了下淘宝的购物车页面，发现他们是输入框输入数字停顿大概零点几秒后再开始发送请求，而不是像我这样每次输入都发送，然后我就找到了js防抖 原文网址：https://juejin.im/post/5b8de829f265da43623c4261?utm_source=gold_browser_extension我把原文缩减了下写了个小demo直接上代码 1234567891011121314html： &lt;input id=&apos;debounce&apos; /&gt;JS:var timer = false;function debounce(delay) &#123; clearTimeout(timer) // 清除未执行的代码，重置回初始化状态 timer = setTimeout(function () &#123; console.log(&apos;函数鸡柳&apos;) &#125;, delay)&#125;let inputb = document.getElementById(&apos;debounce&apos;)inputb.addEventListener(&apos;keyup&apos;, function (e) &#123; debounce(500)&#125;) 函数防抖的要点，需要一个setTimeout来辅助实现,延迟执行需要跑的代码如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始多用于用户名邮箱等等认证，或购物车数量 JS节流规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效 123456789101112131415&lt;input type=&quot;text&quot; id=&quot;d1&quot;&gt;var time = 0document.getElementById(&quot;d1&quot;).onkeyup=function()&#123; set()&#125;function set()&#123; var date = new Date().getTime() if(date-time&gt;=2000)&#123; timer = setTimeout(e=&gt;&#123; console.log(&quot;红烧&quot;) time = date &#125;,2000) &#125;&#125; 然后你就会发现他会每隔2秒执行一次节流我的思路就是每次输入的时候获取当前的毫秒数，如果当前毫秒数减去上一次的毫秒数&gt;=2000了，这时候开始进行定时器的逻辑，定时器结束后把结束的时间换成当前的time函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件 总结 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行]]></content>
      <tags>
        <tag>jacascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于bind，apply，call以及箭头函数的区别]]></title>
    <url>%2F2018%2F12%2F27%2Fthis%2F</url>
    <content type="text"><![CDATA[call,apply不比比，直接上代码 12345678910111213function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// 第一个参数也是作为‘this’使用的对象// 第二个参数是一个数组，数组里的元素用作函数调用中的参数add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 在使用call和apply时候，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 ‘foo’，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转换为对象，像 new Number(7) 这样，而字符串 ‘foo’ 转化成 new String(‘foo’) 这样如果你传的context就null或者undefined，那么window对象就是默认的context（严格模式下默认 context 是 undefined） bindbind是es5新加的，当你调用bind的时候，跟call和apply不同，他返回的是一个新函数，新函数this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。123456789101112function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);console.log(g()); // azertyvar h = g.bind(&#123;a:&apos;yoo&apos;&#125;); // bind只生效一次！console.log(h()); // azertyvar o = &#123;a:37, f:f, g:g, h:h&#125;;console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty 箭头函数在箭头函数中，this与封闭词法上下文的this保持一致。在全局代码中，它将被设置为全局对象1234567891011121314151617var globalObject = this;var foo = (() =&gt; this);console.log(foo() === globalObject); // true//如果将this传递给call、bind、或者apply，它将被忽略。// 接着上面的代码// 作为对象的一个方法调用var obj = &#123;foo: foo&#125;;console.log(obj.foo() === globalObject); // true// 尝试使用call来设定thisconsole.log(foo.call(obj) === globalObject); // true// 尝试使用bind来设定thisfoo = foo.bind(obj);console.log(foo() === globalObject); // true 最后一点，当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。12345678var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // logs 37]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式入门笔记]]></title>
    <url>%2F2018%2F12%2F24%2Freg%2F</url>
    <content type="text"><![CDATA[正则一直是我弱项，闲着没事写笔记学习吧~ RegExp对象js的内置对象RegExp支持正则表达式有两种方法实例化RegExp对象 字面量 var reg = /a/ 构造函数 var reg = new RegExp(‘/a/‘) 元字符正则表达式由两种基本字符类型组成 原义文本字符，也就是我想搜索a那就/a/ 元字符，在正则表达式中有特殊含义的非字母字符比如\b边界，以及 * + ? ^ () {} [] 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行符 \r 回车符 \o 空字符 \f 换页符 \cX 与X对应的控制字符 字符类有时候我们不想特指某个字符，想匹配某个范围内 我们可以用元字符 [] 来构建一个简单的类 所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符 表达式[abc]就把字符a,b,c归为一类，表达式可以匹配这类的字符 字符类取反 使用元字符^创建反向类/负向类 反向类的意思是不属于某类的内容 表达式[^abc]标识不是字符a,b,c的内容 范围类我们想匹配所有数字，或者所有字母的时候，正则提供了范围类 [a-z]就表示从a到z的任意字符 这是个闭区间，也包含a和z本身 也可以连着写[a-zA-Z0-9],如果想匹配-这个字符就在匹配的后面加上-例如[a-z-] 预定义类+边界 预定义类+边界 含义 . 除了换行符和回车符以外的所有字符 \d 数字字符([0-9]) \D 非数字字符([^0-9]) \s 空白符 \S 非空白符 \w 单词字符([a-zA-Z_0-9]) \W 非单词字符 ^ 以xxxx开始 $ 以xxxx结束 \b 单词边界 \B 非单词边界 量词当你希望匹配一个数字出现20次的时候，你可以这样写/\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d/……这样写是极其不友好，谁写是傻子 字符 含义 ? 出现0次或者1次(最多出现一次) + 出现一次或多次(最少出现一次) * 出现0次或多次(任意次) {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 贪婪模式和非贪婪模式比如表达式\d{3,6}，可以匹配到三个数字，也可以是四个五个六个……来看例子 12&apos;12345678&apos;.replace(/\d&#123;3,6&#125;/g,&apos;A&apos;)&apos;A78&apos; 从这可以看出正则表达式默认的是尽可能多的匹配，而不是只匹配到第三个就结束了，这就是贪婪模式 非贪婪模式 让正则表达式尽可能少的匹配，也就是说一旦成功匹配不再继续尝试，就是非贪婪模式做法很简单，在量词后加上?即可 12&apos;12345678&apos;.replace(/\d&#123;3,6&#125;?/,&apos;X&apos;)&quot;X45678&quot; 分组比如我们想匹配 abc 3次的时候我们可以这样写abc{3}但是这样写就会匹配c的3次，而不是整个字母abc的3次，要想作用于整个字母就要使用()来分组(abc){3} 或js里边是 || 而正则是使用 | 可以达到或的效果a|c 反向引用2015-15-25 =&gt; 25/15/2015&#39;2015-12-25&#39;.replace(/(\d{4})-(\d{2})-(\d{2})/,&#39;$3/$2/$1&#39;)如果你不希望捕获分组可以在()内加上?:(?:\d{2}) 前瞻和后瞻 名称 正则 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) exp(?=assert) 的意思就是比如你要匹配a但是a后边必须要跟上数字 就是这样写/\w(?=\d)/，上代码看下和平常的区别1234&apos;a2b2&apos;.replace(/\w\d/,&apos;A&apos;)&quot;Ab2&quot;&apos;a2b2&apos;.replace(/\w(?=\d)/,&apos;A&apos;)&quot;A2b2&quot; 对象属性修饰符 g:global全局搜索，不添加，搜索到第一个停止 i:ignore case 忽略大小写，默认大小写敏感 m:multiple lines 多行搜索 lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置,该属性只有设置标志 g 才能使用。 source 正则表达式的文本字符串 test用于测试字符串参数中是否存在匹配正则表达式模式的字符串 12/\d/g.test(&apos;0&apos;)true 但是你多执行几次就会出现…123456789var reg = /\d/greg1.test(0)truereg1.test(0)falsereg1.test(0)truereg1.test(0)false 这是为撒呢？因为test是以lastIndex属性所指的位置作为下次检索的起始点，所以你就可以遍历一个字符串的所有文本,等它再也找不到可以匹配的文本时，它会自动把 lastIndex 属性重置为 0，所以返回了false 12345678var reg = /\w/gwhile(reg.test(&apos;ab&apos;))&#123; console.log(reg.lastIndex)&#125;12 exec使用正则表达式对字符串进行搜索，如果没有匹配返回null，匹配到返回结果数组,数组的第 0 个元素是与正则表达式相匹配的文本，第1个元素是正则中分组中表达式相匹配的值，一次类推，看实例 12345678var reg = /\d(\w)\d/var ret = reg.exec(&apos;$5a51s28e6&apos;)console.log(ret.index,reg.lastIndex,ret.toString(),ret.input)10&quot;5a5,a&quot;&quot;$5a51s28e6&quot; 从实例中可以看出exec()方法还返回两个属性，index 属性声明的是匹配文本的第一个字符的位置，input属性则存放的是被检索的字符串string。其中5a5 是检索到的字符串，而a是分组(\w)检索出来的属性，再换个写法试试 12345var reg = /\d(\w)(\w)\d/var ret = reg.exec(&apos;$5aw51s28e6&apos;)console.log(ret.toString())&quot;5aw5,a,w&quot; a和w都是分组中两个属性 字符串的对象方法search search()方法用于检索字符串中指定的子字符串，或检索与正则表达式想匹配的子字符串，方法返回第一个匹配结果index，查找不到返回-1，search方法不支持全局匹配，忽略标志g，并且从字符串的开始进行检索 1234&apos;1w5w2w&apos;.search(&apos;1&apos;)0&apos;1w5w2w&apos;.search(&apos;10&apos;)-1 match match()方法将检索字符串，找到一个或多个与正则匹配的文本，是否标志g对结果影响很大]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Redux学习挖坑]]></title>
    <url>%2F2018%2F12%2F23%2FReact-Redux%E5%AD%A6%E4%B9%A0%E6%8C%96%E5%9D%91%2F</url>
    <content type="text"><![CDATA[什么是Redux Redux是一个流行的JavaScript框架，为应用程序提供一个可预测的状态容器。Redux基于简化版本的Flux框架，Flux是Facebook开发的一个框架。在标准的MVC框架中，数据可以在UI组件和存储之间双向流动，而Redux严格限制了数据只能在一个方向上流动 在Redux中，所有的数据（比如state）被保存在一个被称为store的容器中 → 在一个应用程序中只能有一个。store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。要通过本地或远程组件更改状态，需要分发一个action。分发在这里意味着将可执行信息发送到store。当一个store接收到一个action，它将把这个action代理给相关的reducer。reducer是一个纯函数，它可以查看之前的状态，执行一个action并且返回一个新的状态。项目撸起来首先创建一个react脚手架项目create-react-app my-app接下来cd到项目当中，安装reduxyarn add redux -S页面index.jsimport {createStore} from &#39;redux&#39; StateStore对象包含所有数据， 当前时刻的 State，可以通过store.getState()拿到。1234//新建storeconst store = createStore(reducer);const state = store.getState();console.log(state); ActionState 的变化，会导致页面的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置const action = {type:&#39;0&#39;} store.dispatch()派发事件，接受action，将当前的action传输给reducer，生成新的statestore.dispatch(action) Reducerstore收到action后，经过一些逻辑计算也就是reducer，然后生成一个新的state123456789101112//通过reducer遍历//根据老的state和action来生成新的statefunction reducer(state=0,action)&#123; switch (action.type) &#123; case &apos;0&apos;: return state+1 break; default: return state break; &#125;&#125; store.subscribe()订阅事件，一旦 State 发生变化，就自动执行这个函数12345//订阅事件function listener()&#123; console.log(store.getState())&#125;store.subscribe(listener); 下面直接来一个demo吧，index.js123456789101112131415161718192021222324252627282930313233343536import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import &#123;createStore&#125; from &apos;redux&apos;;import App from &apos;./App&apos;;import registerServiceWorker from &apos;./registerServiceWorker&apos;;function reducer(state=0,action)&#123; switch (action.type) &#123; case &apos;0&apos;: return state+1 break; default: return state break; &#125;&#125;const store = createStore(reducer);const state = store.getState();//订阅事件function listener()&#123; console.log(store.getState())&#125;store.subscribe(listener);//派发事件const action = &#123;type:&apos;0&apos;&#125;store.dispatch(action);store.dispatch(action);store.dispatch(action);ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));registerServiceWorker(); 页面打印出 React怎么和Redux一起使用呢 把store.dispatch方法传递给组件，内部可以调用修改状态 Subscribe订阅render函数，每次修改都重新渲染 Redux相关代码，转移到redux.js进行管理 在src目录创建redux.js，然后将reducer函数放入redux.jsindexjs:1234567891011121314import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import &#123;createStore&#125; from &apos;redux&apos;;import App from &apos;./App&apos;;import &#123;reducer,add&#125; from &apos;./redux&apos;;const store = createStore(reducer);function render()&#123; ReactDOM.render(&lt;App store=&#123;store&#125; add=&#123;add&#125;/&gt;, document.getElementById(&apos;root&apos;));&#125;render()store.subscribe(render); redux.js:12345678910111213export function reducer(state=0,action)&#123; switch (action.type) &#123; case &apos;0&apos;: return state+1 break; default: return state break; &#125;&#125;export function add()&#123; return &#123;type:&apos;0&apos;&#125;&#125; 页面app.js12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./App.css&apos;;class App extends Component &#123; render() &#123; var store = this.props.store; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt;&#123;store.getState()&#125;&lt;/p&gt; &lt;button onClick=&#123;e=&gt;store.dispatch(this.props.add())&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 这样页面中，每点击一次button，返回来的state就会加1 更进一步，处理异步，调试工具，与react更优雅的结合Redux默认只处理同步，处理异步，需要redux-thunk插件使用applyMiddleware开始thunk中间件Action可以返回函数，使用dispatch提交actionyarn add redux-thunk --saveindex.js123import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;const store = createStore(reducer,applyMiddleware(thunk)); redux.js1234567export function addd()&#123; return dispatch=&gt;&#123; setTimeout(()=&gt;&#123; dispatch(&#123;type:&apos;0&apos;&#125;) &#125;,1000) &#125;&#125; 刚才咱们返回是对象，这次返回的action是一个函数，在app.js调用后会发现页面在1秒后state返回+1redux调试工具在chrome这个就需要大家科学上网了, 点击这里下载 怎么使用该工具？ 新建store的时候判断window.devToolsExtension 使用compose结合thunk和window.devToolsExtension 调试窗的redux选项卡，实时看到state index.js代码123456import &#123;createStore,applyMiddleware,compose&#125; from &apos;redux&apos;;const store = createStore(reducer,compose( applyMiddleware(thunk), window.devToolsExtension?window.devToolsExtension():a=&gt;a)); 如果出现state未初始化这个错误，建议你把工具更新一下~~ 使用react-reduxyarn add react-redux -S忘记subscribe，记住reducer，action和dispatch即可React-redux提供connect和Provider两个接口来链接index.js1234567import &#123; Provider &#125; from &apos;react-redux&apos;;ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); app.js 1234567891011121314151617181920212223import &#123;connect&#125; from &apos;react-redux&apos;;import &#123;addState,remove&#125; from &apos;./redux&apos;;class App extends React.component&#123; render()&#123; const store = this.props.store; return ( &lt;div&gt; &lt;h1&gt;我永远喜欢新垣结衣&#123;this.props.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;e=&gt;this.props.addState()&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;e=&gt;this.props.remove()&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;//进行装饰器let mapStatetoProps = state=&gt;&#123; return &#123;num : state&#125;&#125;let action = &#123;addState,remove&#125;App = connect(mapStatetoProps,action)(App)//export default App connect 使用装饰器来写可以省略代码，首先yarn eject弹出来个性化配置首先安装一个支持装饰器的插件yarn add babel-plugin-transform-decorators-legacy -D 然后在package.json下的babel添加一个参数1234567&quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;react-app&quot;], &quot;plugins&quot;: [ [&quot;import&quot;,&#123;&quot;libraryName&quot;: &quot;antd-mobile&quot;,&quot;style&quot;: &quot;css&quot;&#125;], [&quot;transform-decorators-legacy&quot;] //就是这个 ] &#125;, 添加之后在页面重新书写connect 123456789101112131415161718192021import &#123;connect&#125; from &apos;react-redux&apos;;import &#123;addState,remove&#125; from &apos;./redux&apos;;@connect( state =&gt; (&#123;num:state&#125;), &#123;addState,remove&#125;)class App extends React.component&#123; render()&#123; const store = this.props.store; return ( &lt;div&gt; &lt;h1&gt;我永远喜欢新垣结衣&#123;this.props.num&#125;&lt;/h1&gt; &lt;button onClick=&#123;e=&gt;this.props.addState()&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;e=&gt;this.props.remove()&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App 这样代码简洁美观]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019]]></title>
    <url>%2F2018%2F12%2F20%2F2019%2F</url>
    <content type="text"><![CDATA[新的一年..赚钱要紧赚钱要紧 &emsp;&emsp;从 2017 年 12 月份 1 号入职到现在有一年了，离开大姐的第一年，我有点想她。]]></content>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.x学习入门]]></title>
    <url>%2F2018%2F12%2F20%2Fwebpack4-x%2F</url>
    <content type="text"><![CDATA[之前一直使用3.x，这次学学4.x，看看跟之前有什么不同的地方没 什么是webpack？ webpack是一个打包工具，他的宗旨是一切静态资源即可打包。有人就会问为什么要webpack？webpack是现代前端技术的基石，常规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack将现代js开发中的各种新型有用的技术，集合打包。 一、前端环境搭建我们使用npm或yarn来安装webpack123npm install webpack webpack-cli -g 或者 yarn global add webpack webpack-cli 在webpack3中，webpack本身和它的cli以前都是在同一个包中，第4版他们两者分开了,新建一个webpack的文件夹，webpack,初始化package.json并安装webpack-cli 12cnpm init -y //-y 默认所有的配置cnpm i webpack webpack-cli --save-dev //局部安装 二、部署webpack在上面搭建好的环境项目中，我们来到package.json里配置我们的scripts123&quot;scripts&quot;: &#123; &quot;dist&quot; : &quot;node_modules/.bin/webpack -p&quot; //使用cnpm run dist 就可以打包我们的项目了&#125;, 三、webpackp配置流程篇我们在开发是一般会打包src下的什么文件呢？ 发布时需要的html，css，js 预编译器stylus，less，sass,es6的高级语法 图片字体资源.png，.gif，.ico，.jpg 文件间的require别名@等修饰符等等 webpack-dev-server以及跨域处理 jQuery插件全局使用通过这几点来讲解webpack中webpack.config.js的配置首先在同目录下创建webpack.config.js文件，配置总览大概是这样123456789101112module.exports=&#123; //入口文件的配置项 entry:&#123;&#125;, //出口文件的配置项 output:&#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; entry：配置入口文件的地址，可以是单一入口，也可以是多入口。output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。module：配置模块，主要是解析CSS和图片转换压缩等功能。plugins：配置插件，根据你的需要配置不同功能的插件。devServer：配置开发服务功能。 首先是入口文件123456entry: &apos;./index.js&apos;, //可配置多入口文件entry:&#123; &apos;index&apos; : &apos;./index.js&apos;, &apos;demo&apos; : &apos;./demo.js&apos;,&#125; output选项（出口配置）1234567891011121314151617181920//出口文件的配置项output:&#123; //打包的路径 path:path.resolve(__dirname,&apos;dist&apos;), //打包后的引用路径 publicPath: &apos;dist&apos;, //打包的文件名称 filename:&apos;bundle.js&apos; &#125;,//多入口情况下output:&#123; //打包的路径 path:path.resolve(__dirname,&apos;dist&apos;), //打包后的引用路径 publicPath: &apos;dist&apos;, //打包的文件名称 filename:&apos;js/[name].js&apos; &#125;,//[name]的意思是根据入口文件的名称，打包成相同的名称，有几个入口文件，就可以打包出几个文件。 直接这样写是不对的，需要在头部引入pathconst path = require(&#39;path&#39;)其中path.resolve(__dirname,’dist’)就是获取了项目的绝对路径。接下来在根目录下创建index.js，然后运行node_modules/.bin/webpack如果你是全局安装，直接webpack即可，此条命令针对局部安装 设置webpack-dev-server要执行webpack-dev-server首先要使用npm下载cnpm install webpack-dev-server –-save-dev最简单的几项配置如下123456789101112131415devServer:&#123; //设置基本目录结构 contentBase:path.resolve(__dirname,&apos;dist&apos;), //服务器的IP地址，可以使用IP也可以使用localhost host:&apos;localhost&apos;, //服务端压缩是否开启 compress:true, //配置服务端口号 port:1717 proxy : [&#123; context: [&apos;/admin&apos;], target: &quot;http://mcljp.com&quot;, changeOrigin : true &#125;]&#125; contentBase:配置服务器基本运行路径，用于找到程序打包地址host：服务运行地址，建议使用本机IP，这里为了讲解方便，所以用localhostcompress：服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习port：服务运行端口，建议不使用80，很容易被占用，这里使用了1717.proxy : 本地代理，可进行跨域 开启热更新，你要是直接webpack-dev-server是不行的，需要在json文件下配置下scripts1234&quot;scripts&quot;: &#123; &quot;dev&quot;:&quot;webpack-dev-server --open&quot; &#125;,//--open命令运行后自动打开浏览器进行浏览 配置好保存后，在终端里输入 npm run dev 就可以进行浏览了 四、配置模块 loaders是Webpack最重要的功能之一，通过使用不同的Loader，Webpack可以的脚本和工具，从而对不同的文件格式进行特定处理。test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）query：为loaders提供额外的设置选项（可选） 打包css文件根目录下创建css文件，然后js文件require引入,npm安装style-loader，css-loadercnpm install style-loader css-loader --save-dev webpack.config.js的modules修改为下12345678module:&#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ]&#125; 打包HTML文件打包html我们需要用上插件html-webpack-plugin，使用npm安装插件，并在头部引用12npm install --save-dev html-webpack-pluginconst htmlPlugin= require(&apos;html-webpack-plugin&apos;); html-webpack-pugin基本属性如下title: 用来生成页面的 title 元素filename: 输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录。template: 模板文件路径，比如‘./index.html’，favicon: 添加特定的 favicon 路径到输出的 HTML 文件中。minify: {} | false , 传递 html-minifier 选项给 minify 输出hash: true | false, 如果为 true, 将添加一个唯一的 webpack 编译 hash 到所有包含的脚本和 CSS 文件，对于解除 cache 很有用。cache: true | false，如果为 true, 这是默认值，仅仅在文件修改之后才会发布文件。showErrors: true | false, 如果为 true, 这是默认值，错误信息会写入到 HTML 页面中chunks: 允许只添加某些块 (比如，仅仅 unit test 块)chunksSortMode: 允许控制块在添加到页面之前的排序方式，支持的值：’none’ | ‘default’ | {function}-default:’auto’excludeChunks: 允许跳过某些块，(比如，跳过单元测试的块)chunks：chunks 默认会在生成的 html 文件中引用所有的 js 文件，当然你也可以指定引入哪些特定的文件。根目录下创建index.html12345678910plugins:[ new htmlWebpackPlugin(&#123; template : &apos;index.html&apos;, filename : &apos;index.html&apos;, title : title, inject : true, hash : true, chunks : [&apos;index&apos;] &#125;),] 终端进行打包，你就会发现html文件也被打包在我们的dist目录下了。 图片，字体打包要将图片和字体打包我们需要安装url-loader，首先进行安装npm install --save-dev url-loader接下来进行配置12345678test: /\.(png|jpg|gif)/,use: [&#123; loader: &apos;url-loader&apos;, options: &#123; limit: 5000, outputPath: &apos;resource/&apos; &#125; &#125;] limit : 文件大小小于limit参数，url-loader将会把文件转为DataURLoutputPath : 表示输出文件路径前缀。图片经过url-loader打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。图片被打包时，就会在输出文件夹下新建（如果没有）一个名为resource的文件夹，把图片放到里面 css单独打包安装后，config.js文件头部引用12npm install --save-dev extract-text-webpack-pluginconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); 引入成功创建实例后需要在plugins属性中进行配置12345678910const extractTextPlugin = new extractTextPlugin(&quot;/css/index.css&quot;)&#123; test: /\.css$/, use : extractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [ &#123; loader: &apos;css-loader&apos; &#125;, ] &#125;)&#125; ES6转ES6Babel的安装与配置cnpm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react在webpack中配置Babel的方法如下12345test:/\.(jsx|js)$/,use:&#123; loader:&apos;babel-loader&apos;,&#125;,exclude:/node_modules/ 需要在根目录下创建.babelrc文件123&#123; &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]&#125; 打包第三方库，比如jQuery使用plugin全局引用ProvidePlugin是一个webpack自带的插件，Provide的意思就是装备、提供。因为ProvidePlugin是webpack自带的插件，所以要先再webpack.config.js中引入webpackconst webpack = require(&#39;webpack&#39;)引入成功后配置我们的plugins模块12345plugins:[ new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot; &#125;)], 一些杂货铺插件，可用可不用new webpack.BannerPlugin(&#39;买菜的家朋版权所有&#39;)123456789//抽离第三方库，单独打包，不易造成代码冗余new webpack.optimize.CommonsChunkPlugin(&#123; //name对应入口文件中的名字，我们起的是jQuery name:[&apos;jquery&apos;], //把文件打包到哪里，是一个路径 filename:&quot;assets/js/[name].js&quot;, //最小打包的文件模块数，这里直接写2就好 minChunks:2&#125;), 补充：目前发现与之前3.x有两处不同1.webpack.optimize.CommonsChunkPlugin这个打包独立模块的插件已被抛弃更改为123456optimization: &#123; splitChunks: &#123; name: &apos;common&apos;, filename : &apos;js/base.js&apos; &#125; &#125; 2.css打包插件extractTextPlugin已不能进行webpack4.0的打包，需要更新12345678cnpm install --save-dev extract-text-webpack-plugin@next 然后在打包就正常了&quot;devDependencies&quot;: &#123; ... &quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;, ...&#125;]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
